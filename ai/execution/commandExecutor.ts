/**
 * Command Executor
 * Protected execution engine that requires approval tokens
 * 
 * ARCHITECTURAL GUARANTEE:
 * This is the ONLY code path that can execute state mutations.
 * It requires a valid approval token, which can only be generated by user approval.
 */

import type { ActionCommand, ApprovalToken, ExecutionResult } from '../schemas/commandSchema'
import { executorRegistry } from './executorRegistry'
import { approvalQueue, verifyApprovalToken } from './approvalQueue'

/**
 * Command Executor singleton
 * Executes approved commands
 */
class CommandExecutor {
  /**
   * Execute an approved command
   * Requires valid approval token
   */
  async execute(commandId: string, approvalToken: ApprovalToken): Promise<ExecutionResult> {
    // Step 1: Verify approval token
    if (!this.verifyApproval(commandId, approvalToken)) {
      return {
        commandId,
        success: false,
        message: 'Execution failed: Invalid approval token',
        error: 'Unauthorized: No valid approval token provided',
      }
    }
    
    // Step 2: Get command from approval queue (it was stored during approval)
    // Note: Command is passed via the approval flow, not retrieved from queue
    // We'll need to pass the command directly
    const command = approvalQueue.getForApproval(commandId)
    if (!command) {
      // Command should be passed directly during execution
      return {
        commandId,
        success: false,
        message: 'Execution failed: Command not found',
        error: 'Command not found or expired',
      }
    }
    
    // Step 3: Get executor for command type
    const executor = executorRegistry.getExecutor(command.type)
    
    // Step 4: Execute command
    try {
      const result = await executor(command.payload)
      
      return {
        commandId,
        success: true,
        message: this.generateSuccessMessage(command),
        data: result,
      }
    } catch (error) {
      console.error('Command execution failed:', error)
      
      return {
        commandId,
        success: false,
        message: 'Failed to execute command',
        error: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }
  
  /**
   * Execute command with approval token (alternative signature)
   * Takes command directly instead of looking it up
   */
  async executeCommand(command: ActionCommand, approvalToken: ApprovalToken): Promise<ExecutionResult> {
    // Verify approval token
    if (!this.verifyApproval(command.id, approvalToken)) {
      return {
        commandId: command.id,
        success: false,
        message: 'Execution failed: Invalid approval token',
        error: 'Unauthorized: No valid approval token provided',
      }
    }
    
    // Get executor for command type
    const executor = executorRegistry.getExecutor(command.type)
    
    // Execute command
    try {
      const result = await executor(command.payload)
      
      return {
        commandId: command.id,
        success: true,
        message: this.generateSuccessMessage(command),
        data: result,
      }
    } catch (error) {
      console.error('Command execution failed:', error)
      
      return {
        commandId: command.id,
        success: false,
        message: 'Failed to execute command',
        error: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }
  
  /**
   * Verify approval token
   */
  private verifyApproval(commandId: string, token: ApprovalToken): boolean {
    // Check command ID matches
    if (token.commandId !== commandId) {
      return false
    }
    
    // Verify signature
    return verifyApprovalToken(token)
  }
  
  /**
   * Generate success message based on command
   */
  private generateSuccessMessage(command: ActionCommand): string {
    const [entity, operation] = command.type.split('.')
    
    switch (operation) {
      case 'create':
        return `Created ${entity} successfully`
      case 'add':
        return `Added to ${entity} successfully`
      case 'update':
        return `Updated ${entity} successfully`
      case 'delete':
      case 'remove':
        return `Deleted ${entity} successfully`
      default:
        return 'Command executed successfully'
    }
  }
}

// Export singleton instance
export const commandExecutor = new CommandExecutor()
